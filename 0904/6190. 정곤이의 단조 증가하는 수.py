"""
정곤이는 자신이 엄청난 수학자임을 증명하기 위해,
어떤 규칙 만족하는 수를 찾아보기로 했다.
그 규칙은 단조 증가하는 수인데,
각 숫자의 자릿수가 단순하게 증가하는 수를 말한다.
어떤 k자리 수 X = d1d2…dk 가 d1 ≤ d2 ≤ … ≤ dk 를 만족하면 단조 증가하는 수이다.
예를 들어 111566, 233359는 단조 증가하는 수이고,
12343, 999888은 단조 증가하는 수가 아니다.
양의 정수 N 개 A1, …, AN이 주어진다.
 1 ≤ i < j ≤ N 인 두 i, j에 대해,
 Ai x Aj값이 단조 증가하는 수인 것들을 구하고
 그 중의 최댓값을 출력하는 프로그램을 작성하라.

"""

# 아니 난 진짜 수학 좋아하는 놈들이 싫다

T = int(input())  # 테스트 케이스 받고

for test_case in range(1, T + 1):  # 테.케 돌면서

    N = int(input())  # 들어온 숫자 갯수

    AN = list(map(int, input().split()))  # 숫자 배열들

    # 여기서 애들을 곱해가지고, 단조증가인 꼴 중에 가장 큰걸 구하라는거지
    # 아 이거 조합쓰면 밥일거 같은데.................

    product = []  # 일단 얘네 두개씩 곱한거 저장할 배열

    # 돌아가면서 하나씩 뽑아서 곱하고 배열에 넣기 전에
    # char로 형변환 해서 요소 체크한다음에
    # 다시 그걸 int로 바꿔서 크기 비교하고 단조증가 아니면 안넣는거
    # 이거 에반가?
    # 걍 해보지 뭐

    max_val = -1  # 최대값 저장용 ( 아!@!!!!!!!!!!!!!!!!!!!! ㅆ ㅃㅆ ㅓㅖㅒㅁ헐마이ㅓㅎㅍㄴ;ㅡㄴ엦ㄷㅁㅎ)
    # 마이너스 1로 해 야
    # 그런데 문제 조건엔 양의 정수만 주어지니까, 아무것 도 없을 떄 - 1 로 뽑으라고 한 조건
    # 충 족 한 댄ㄷㅏ 내가 이거때문에 1시간반을 썩혔다고 진짜욕나오네

    is_valid = True  # 단조 증가가 맞는가?

    for i in range(N):  # 그래 일단 첫째 수 돌아야하니까 포 문 돌리고
        for j in range(i + 1, N):  # 이건 두번째 수 용 포문 (왜 i+1로 시작하냐면 중복 방지)
            temp_pro = AN[i] * AN[j]  # 곱하고
            string_temp = str(temp_pro)  # 문자열로 쓰게 문자열로 바꾸고
            is_valid = True  # 단조증가 참거짓 초기화
            for k in range(len(string_temp) - 1):  # 문자열 돌면서
                if string_temp[k] > string_temp[k + 1]:  # 단조증가 조건 아니라면
                    is_valid = False  # 니 아니다
                    break  # 나가
            if is_valid:  # 맞으면
                if temp_pro > max_val:  # 최대값 뽑죠
                    max_val = temp_pro  # 최대값 저장

    print(f'#{test_case} {max_val}')
