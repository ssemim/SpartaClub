"""
오셀로라는 게임은 흑돌과 백돌을 가진 사람이 번갈아가며
보드에 돌을 놓아서 최종적으로 보드에 자신의 돌이 많은 사람이 이기는 게임이다.

보드는 4x4, 6x6, 8x8(가로, 세로 길이) 크기를 사용한다.
 6x6 보드에서 게임을 할 때, 처음에 플레이어는 다음과 같이 돌을 놓고 시작한다
(B : 흑돌, W : 백돌).

그리고 흑, 백이 번갈아가며 돌을 놓는다.
처음엔 흑부터 시작하는데 이 때 흑이 돌을 놓을 수 있는 곳은 다음과 같이 4군데이다.
플레이어는 빈공간에 돌을 놓을 수 있다.

단, 자신이 놓을 돌과 자신의 돌 사이에 상대편의
돌이 있을 경우에만 그 곳에 돌을 놓을 수 있고,
그 때의 상대편의 돌은 자신의 돌로 만들 수 있다.
(여기에서 "사이"란 가로/세로/대각선을 의미한다.)
(2, 3) 위치에 흑돌을 놓은 후의 보드는 다음과 같다.

이런 식으로 번갈아가며 흑, 백 플레이어가 돌을 놓는다.
만약 돌을 놓을 곳이 없다면 상대편 플레이어가 다시 돌을 놓는다.
보드에 빈 곳이 없거나 양 플레이어 모두 돌을 놓을 곳이 없으면
게임이 끝나고 그 때 보드에 있는 돌의 개수가 많은 플레이어가 승리하게 된다.

 [입력]
첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 보드의
한 변의 길이 N과 플레이어가 돌을 놓는 횟수 M이 주어진다. N은 4, 6, 8 중 하나이다.
그 다음 M줄에는 돌을 놓을 위치와 돌의 색이 주어진다.
돌의 색이 1이면 흑돌, 2이면 백돌이다.
만약 3 2 1이 입력된다면 (3, 2) 위치에 흑돌을 놓는 것을 의미한다.
돌을 놓을 수 없는 곳은 입력으로 주어지지 않는다.

 [출력]
각 테스트 케이스마다 게임이 끝난 후 보드 위의 흑돌, 백돌의 개수를 출력한다.
흑돌이 30개, 백돌이 34인 경우 30 34를 출력한다.

"""

T = int(input())  # 테스트 케이스 받고

for test_case in range(1, 1 + T):  # 테스트 케이스 돌면서

    # 보드의 한 변 길이 N
    # 돌을 놓는 횟수 M

    N, M = map(int, input().split())
    arr = [[0] * N for _ in range(N)]

    # 빈공간 0으로 체크한 게임 맵 생성

    black = 0  # 검은 돌
    white = 0  # 하얀 돌

    # 상하좌우 + 대각선4개
    dr = [-1, 1, 0, 0, -1, -1, 1, 1]
    dc = [0, 0, -1, 1, -1, 1, -1, 1]

    # 게임판 만들기 N*N
    # board[i][j] == 0 : 돌이 없는 상태
    # board[i][j] == 1 : 흑돌
    # board[i][j] == 2 : 백돌
    board = [[0] * N for _ in range(N)]

    # 게임판 처음에 백돌과 흑돌을 2개씩 놓고 시작
    # 백돌
    board[N // 2 - 1][N // 2 - 1] = board[N // 2][N // 2] = 2
    # 흑돌
    board[N // 2 - 1][N // 2] = board[N // 2][N // 2 - 1] = 1

    # 돌을 놓는 작업을 M번 한다.
    for i in range(M):
        # 놓을 돌의 위치 정보, 색
        # 문제에서 사용하는 좌표값이 내 생각과 맞는가??
        c, r, color = map(int, input().split())
        r -= 1
        c -= 1

        # r,c 위치에 돌 놓기
        board[r][c] = color

        # (r,c) 위치 기준으로 8방향 델타 탐색
        for d in range(8):
            # d방향으로 뻗어나간 칸의 개수k
            # 다른색 돌 위치 기억할 배열
            mem = []
            for k in range(1, N):
                # d방향으로 k칸 뻗어나간 위치 계산
                # 현재위치 기준 d방향으로 k칸 뻗어나감
                nr = r + dr[d] * k
                nc = c + dc[d] * k

                # 보드의 크기를 벗어난 경우
                if not (0 <= nr < N and 0 <= nc < N):
                    break

                # 돌이 없는 경우
                elif board[nr][nc] == 0:
                    break

                # 다른색 돌인 경우
                elif board[nr][nc] != color:
                    # 다른 색 돌들은 나중에 뒤집을 수도 있으니
                    # 리스트에 넣어서 저장해둔다.
                    mem.append((nr, nc))

                # 같은색 돌인 경우
                elif board[nr][nc] == color:
                    # 지금까지 만난 다른 색 돌을 모두 뒤집어서
                    # 내 색으로 맞춘다.
                    while mem:
                        rr, rc = mem.pop()
                        board[rr][rc] = color
                    # 같은색 돌을 만나서 바꿧으면 더이상 진행x
                    break

    # 돌 놓기를 다 했으면 흰돌의 개수와 검은돌의 개수 세기
    # 백돌
    w = 0
    # 흑돌
    b = 0

    for i in range(N):
        for j in range(N):
            if board[i][j] == 1:
                b += 1
            elif board[i][j] == 2:
                w += 1

    print(f"#{test_case} {b} {w}")
