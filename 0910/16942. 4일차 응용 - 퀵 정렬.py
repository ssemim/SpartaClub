"""
퀵 정렬을 구현해 N개의 정수를 정렬해 리스트 A에 넣고,
A[N//2]에 저장된 값을 출력하는 프로그램을 만드시오.
"""

# A : 정렬 대상 배열
# l, r : 정렬 범위 시작인덱스, 종료인덱스
def quicksort(A, l, r):
    if l < r:
        # 기준원소를 정해서 기준원소의 위치가 확정되고
        p = partition(A, l, r)

        # 기준원소의 왼쪽 부분 정렬
        quicksort(A, l, p - 1)
        # 기준원소의 오른쪽 부분 정렬
        quicksort(A, p + 1, r)


def partition(A, l, r):
    # A의 가장 왼쪽에 있는 원소가 기준
    p = A[l]

    # p보다 작은 원소를 왼쪽에
    # p보다 큰 원소를 오른쪽에

    # 앞에서부터 p보다 큰 원소를 찾고
    # 뒤에서부터 p보다 작은 원소를 찾으면
    # 이 두 원소는 위치가 잘못되어 있으니 서로 교환

    # 앞에서부터 찾기 위한 인덱스
    i = l
    # 뒤에서부터 찾기 위한 인덱스
    j = r

    # i랑 j가 교차하기 전까지
    while i <= j:
        # i위치는 왼쪽에서부터 +1 씩 증가
        # i번 인덱스에 있는 원소가 p보다 작으면
        # 자기자리가 맞음, + 1 해가며 다음원소 탐색
        while i <= j and A[i] <= p:
            i += 1

        # j위치는 오른쪽에서부터 -1 씩 감소
        # j번 인덱스에 있는 원소가 p보다 크면
        # 자기자리가 맞음, -1 해가면서 다음원소 탐색
        while i <= j and A[j] >= p:
            j -= 1

        # 두개의 반복문이 끝나고 나서
        # 여전히 i가 j보다 작으면
        # p보다 큰 원소가 i번에 있다
        # p보다 작은 원소가 j번에 있다.
        # 그럼 바꿔 주면 된다.
        if i < j:
            A[i], A[j] = A[j], A[i]

    # i랑 j가 교차
    # 왼쪽에는 기준보다 작은 원소들이 모여있고
    # 오른쪽에는 기준보다 큰 원소들이 모여있음
    # 기준 원소를 그 사이에 끼워넣으면 위치 확정
    A[l], A[j] = A[j], A[l]
    # i와 j가 교차했으므로 j가 i보다 작은 상황
    # 기준원소(피벗)을 그중에 작은것과 바꿔야
    # 작은원소들이 왼쪽, 큰원소들이 오른쪽 이라는 규칙을
    # 지킬수 있게 된다.

    # 기준원소의 위치는 어디로 확정?? => j
    return j


T = int(input())  # 테스트 케이스 받고

for test_case in range(1, T + 1):  # 테스트 케이스 돌면서

    N = int(input())  # 원소 개수 받고
    arr = list(map(int, input().split()))  # 배열 받고

    quicksort(arr, 0, N - 1)

    print(f'#{test_case} {arr[N // 2]}')
