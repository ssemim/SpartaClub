"""
호석이는 불면증에 걸렸다. 그래서 잠이 안 올 때의 민간요법 중 하나인 양 세기를 하려고 한다.
호석이는 1번 양부터 순서대로 세는 것이 재미없을 것 같아서 N의 배수 번호인 양을 세기로 하였다.
즉, 첫 번째에는 N번 양을 세고, 두 번째에는 2N번 양, … , k번째에는 kN번 양을 센다.
이렇게 숫자를 세던 호석이에게 잠은 더 오지 않고 다음과 같은 궁금증이 생겼다.
이전에 셌던 번호들의 각 자리수에서 0에서 9까지의 모든 숫자를 보는 것은 최소 몇 번 양을 센 시점일까?
예를 들어 N = 1295이라고 하자.
첫 번째로 N = 1295번 양을 센다. 현재 본 숫자는 1, 2, 5, 9이다.
두 번째로 2N = 2590번 양을 센다. 현재 본 숫자는 0, 2, 5, 9이다.
현재까지 본 숫자는 0, 1, 2, 5, 9이다.
세 번째로 3N = 3885번 양을 센다. 현재 본 숫자는 3, 5, 8이다.
현재까지 본 숫자는 0, 1, 2, 3, 5, 8, 9이다.
네 번째로 4N = 5180번 양을 센다. 현재 본 숫자는 0, 1, 5, 8이다.
현재까지 본 숫자는 0, 1, 2, 3, 5, 8, 9이다.
다섯 번째로 5N = 6475번 양을 센다. 현재 본 숫자는 4, 5, 6, 7이다.
현재까지 본 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9이다.
5N번 양을 세면 0에서 9까지 모든 숫자를 보게 되므로 호1945. 간단한 소인수분해석이는 양 세기를 멈춘다.
"""

# 호석이 제정신 아닌듯;

T = int(input())  # 테스트 케이스 받고

# 최소 몇 번 양을 세었을때, 이전에 봤던 숫자들의 자리수에서 0에서 9까지의 모든 숫자를 보게 되는가

for test_case in range(1, T + 1):  # 테스트 케이스 돌면서

    N = int(input())  # N의 배수 양을 셀거야
    arr = []  # 0~9까지 숫자 들어왔는지 안들어왔는지 체크 할 배열
    count = 1  # 몇 번 곱했는지 체크할 변수

    # 그러니까 arr안에 겹치는 것 없이 0 ~ 9 까지 다 들어갔을때의
    # 카운트 값을 반환하고
    # while 문 밖으로 빠져나오면 되지 않을까?

    while 1:
        now = N * count  # 지금 수
        string_now = str(now)  # 지금수 문자열로 바꾸고
        for c in string_now:  # 문자열 돌면서
            if c not in arr:  # c가 배열 안에 없으면
                arr.append(c)  # 집어넣음
        if len(arr) == 10:  # 배열에 0부터 9까지 다 들어가서 길이 10되면
            break  # 브레이크
        count += 1  # 카운트 수 하나 더해주기
        
        # 아 ㅁㅊ 세상에 지금까지 전부 오류떴던게 문제에 호석이는 xN번 양을센다 인데
        # 이걸 안곱해준거였네 제정신 아니다 
        # 이걸로 페일을 세 번 띄웠다고??????????????
        
        answer = count * N

    print(f'#{test_case} {answer}')
